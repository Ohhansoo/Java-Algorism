package com.algorism.graph.dijkstra;


import com.algorism.graph.topologySort.TopologySort_MyAnswer;

import java.io.IOException;

/**
 * 다익스트라 : 그래프에서 최단 거리를 구하는 알고리즘
 *            특정 노드에서 다른 노드들의 최단 거리 구하는 문제
 * [위상 정렬]
 *  기능 : 출발 노드와 모든 노드간의 최단 거리 탐색
 *  특징 : 에지는 모두 양수
 *  시간 복잡도(노드 수 : V, 에지 수 : E) : O(ElogV)
 *
 * [원리 이해]
 *  1. 인접 리스트로 그래프 구현
 *  2. 최단 거리 배열 초기화하기
 *  3. 값이 가장 작은 노드 고르기
 *  4. 최단 거리 배열 업데이트하기
 *      - Min(선택 노드의 최단 거리 배열의 값 + 에지 가중치, 연결 노드의 최단 거리 배열의 값)
 *  5. 과정 3~4를 반복해 최단 거리 배열 완성하기
 * */
public class Dijkstra {
    public static void main(String[] args) throws IOException {
        Dijkstra_MyAnswer myAnswer = new Dijkstra_MyAnswer();

        //문제 1(08-4-056) : 최단 경로 구하기
        /************************************** 개 요 *************************************
         * 에지의 가중치가 10 이하의 자연수인 방향 그래프가 있다. 이 그래프의 시작점에서
         * 다른 모든 노드로의 최단 경로를 구하시오
         * */
        //입력 : 1번째 줄에 노드의 개수 V와 에지의 개수 E가 주어진다(1 <= V <= 20,000, 1 <= E <= 300,000)
        //      모든 노드에는 1부터 V까지 번호가 매겨져 있다.
        //      2번째 줄에 출발 노드의 번호 K가 주어진다(1 <= K <= V)
        //      3번째 줄에서 E개의 줄에 걸쳐 각 에지의 정보(u, v, w)가 순서대로 주어진다.
        //      이는 u에서 v로 가는 가중치 w인 에지가 존재한다는 뜻으로, u와 v는 서로 다르다.
        //      두 노드 사이에 에지가 2개 이상 존재할 수 있다는 것에 유의하자.
        //출력 : 1번째 줄부터 V개의 줄에 걸쳐, i번째 줄에 i번 노드까지 최단 경로값을 출력한다.
        //      시작점은 0, 경로가 없을 때는 INF를 출력한다.
        //[예제 입력1] : 5 6 //노드 개수, 에지 개수
        //              1   // 출발 노드의 번호
        //              5 1 1 //각 에지의 정보(u v w) -> u에서 v로 가는 가중치 w
        //              1 2 2
        //              1 3 3
        //              2 3 4
        //              2 4 5
        //              3 4 6
        //[예제 출력1] : 0
        //              2
        //              3
        //              7
        //              INF
        System.out.println("문제 1(08-3-053) : 줄 세우기");
        myAnswer.shortestPath();
    }
}
