package com.algorism.graph.implementation;

import java.io.IOException;

/*
*
* */
public class implementation {

    public static void main(String[] args) throws IOException {
        implementation_MyAnswer myAnswer = new implementation_MyAnswer();

        //문제 1(08-1-046) : 특정 거리의 도시 찾기
        /************************************** 개 요 *************************************
         * 1번부터 N번까지의 도시와 M개의 단방향 도로가 존재하고, 모든 도로의 거리는 1인 도시가 있다.
         * 도시 X로부터 출발해 도달할 수 있는 모든 도시 중 최단 거리가 정확히 K인 모든 도시들의 번호를 출력하시오
         * */
        //입력 : 1번째 줄에 도시의 개수(N), 도로의 개수(M), 거리 정보(K), 출발 도시의 번호(X)가 입력된다
        //      (2 <= N <= 300,000) (1 <= M <= 1,000,000) (1 <= K <= 300,000) (1 <= X <= N)
        //      이후 M개의 줄에 걸쳐 2개의 자연수 A,B가 공백으로 구분돼 주어진다. A번 도시에서 B번 도시로 이동하는 단방향 도로가 존재한다는 뜻이다
        //      (1 <= A,B <= N) 단 A와 B가 같을 수 없다
        //출력 : X로부터 출발해 도달 가능한 도시 중 최단 거리가 K인 모든 도시의 번호를 1줄에 1개씩 오름차순으로 출력한다. 없으면 -1로 출력한다.
        //[예제 입력1] : 4 4 2 1 // 도시 개수, 도로 개수, 거리 정보, 출발 도시 번호
        // :            1 2
        //              1 3
        //              2 3
        //              2 4
        //[예제 출력1]    4
        System.out.println("문제 1(08-1-046) : 특정 거리의 도시 찾기");
        myAnswer.findCity4SpecificDistance();

        //문제 2(08-1-047) : 효율적으로 해킹하기
        /************************************** 개 요 *************************************
         * 해커 김지민은 해커다.
         * 신뢰하는 관계와 신뢰하지 않는 관계로 이루어진 N개의 컴퓨터가 있다.
         * A와 B를 신뢰할 경우 B를 해킹하면 A도 해킹할 수 있다.
         * 이 회사의 컴퓨터의 신뢰하는 관계가 주어졌을 때 한 번에 가장 많은 컴퓨터를 해킹할 수 있는 번호를 출력하는 프로그램을 작성하시오
         * */
        //입력 : 1번째 줄에 N과 M이 들어온다. N은 10,000보다 작거나 같은 자연수, M은 100,000보다 작거나 같은 자연수다.
        //      2번째 줄부터 M개의 줄에 신뢰하는 관계가 'A B'와 같은 형식으로 들어오며, 'A가 B를  신뢰한다'를 의미한다.
        //      컴퓨터는 1번부터 N번까지 번호가 1개씩 매겨져 있다.
        //출력 : 1번째 줄에 김지민이 한 번에 가장 많은 컴퓨터를 해킹할 수 있는 컴퓨터의 번호를 오름차순 출력한다.
        //[예제 입력1] : 5 4 // 컴퓨터 개수(노드), 신뢰 관계 개수(에지)
        //              3 1
        //              3 2
        //              4 3
        //              5 3
        //[예제 출력1]    1 2
        System.out.println("문제 2(08-1-047) : 효율적으로 해킹하기");
        myAnswer.hackingEfficiently();

        //문제 3(08-1-048) : 이분 그래프 판별하기
        /************************************** 개 요 *************************************
         * 각 집합에 속한 노드끼리 서로 인접하지 않는 두 집합으로 그래프의 노드를 나눌 수 있을 때 이 그래프를
         * '이분 그래프(bipartite graph)'라고 한다.
         *  그래프가 입력으로 주어졌을 때 이 그래프가 이분 그래프인지 여부를 판별하는 프로그램을 작성하시오.
         * */
        //입력 : 입력은 여러 개의 사례로 구성돼 있는데, 1번째 줄에 테스트 케이스의 개수 K(2 <= K <= 5)가 주어진다.
        //      각 사례의 1번째 줄에 그래프의 노드의 개수 V(1 <= V <= 20,000)와
        //      에지의 개수 E(1 <= E <= 200,000)가 빈칸을 사이에 두고 순서대로 주어진다.
        //      각 노드에는 1부터 V까지 차례로 번호가 붙어 있다.
        //      이어서 2번째 줄부터 E개의 줄에 걸쳐 에지와 관련된 정보가 주어지는데
        //      각 줄에 인접한 두 노드의 번호가 공백 문자를 사이에 두고 주어진다.
        //출력 : K개의 줄에 걸쳐 입력으로 주어진 그래프가 이분 그래프이면 YES, 아니면 NO를 순서대로 출력한다.
        //[예제 입력1] : 2 //테스트 케이스 개수
        //              3 2 //노드 개수, 에지 개수
        //              1 3
        //              2 3
        //              4 4
        //              1 2
        //              2 3
        //              3 4
        //              4 2
        //[예제 출력1]    YES
        //               NO
        System.out.println("문제 3(08-1-048) : 이분 그래프 판별하기");
        myAnswer.identifyBipartiteGraph();

        //문제 4(08-1-049) : 물의 양 구하기
        /************************************** 개 요 *************************************
         * 각 부피가 A, B, C (1 <= A,B,C <= 200)리터인 3개의 물통이 있다.
         * 처음에는 앞의 두 물통은 비어 있고, 3번째 물동은 가득 차 있다.
         * 이제 어떤 물통에 들어 있는 물을 다른 물통으로 쏟아 부을 수 있는데,
         * 이 때는 한 물통이 비거나, 다른 한 물통이 가득 찰 때까지 물을 부을 수 있다.
         * 이 과정에서 손실되는 물은 없다고 가정한다.
         * 이와 같은 과정을 거치다 보면 3번째 물통(용령이 C인)에 담긴 물의 양이 변할 수도 있다.
         * 1번째 물통(용량이 A인)이 비어 있을 때 3번째 물통(용량이 C인)에 담겨 있을 수 있는 물의 양을 모두 구하는 프로그램을 작성하시오.
         * */
        //입력 : 1번째 줄에 세 정수 A, B, C가 주어진다.
        //출력 : 1번째 줄에 공백으로 구분해 답을 출력한다. 각 용량은 오름차순 정렬한다.
        //[예제 입력1] : 8 9 10 //A B C
        //[예제 출력1] : 1 2 8 9 10
        System.out.println("문제 4(08-1-049) : 물의 양 구하기");
        myAnswer.findTheAmountOfWater();


    }

}
