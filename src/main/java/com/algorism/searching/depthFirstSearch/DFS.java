package com.algorism.searching.depthFirstSearch;

import java.io.IOException;

/**
 * 깊이 우선 탐색 : 그래프 완전 탐색 기법 중 하나
 *                그래프의 시작 노드에서 출발하여 탐색할 한 쪽 분기를 정한다
 *                최대 깊이까지 탐색을 마친 후 다른 쪽 분기로 이동하여 다시 탐색을 수행
 *                한 번 방문한 노드를 다시 방문하면 안 되므로 노드 방문 여부를 체크할 배열이 필요
 *                그래프는 인접 리스트로 표현,
 *  - 기능 : 그래프 완전 탐색
 *  - 특징 : 재귀 함수로 구현, 스택 자료구조 이용, 후입선출(LIFO)
 *  - 시간 복잡도(노드 수 : V, 에지 수 : E) : O(V + E)
 *  - 응용 문제 : 단절점 찾기, 단절선 찾기, 사이클 찾기, 위상 정렬
 *  [과정]
 *   1. DFS를 시작할 노드를 정한 후 사용할 자료구조 초기화하기
 *   2. 스택에서 노드를 꺼낸 후 꺼낸 노드의 인접 노드를 다시 스택에 삽입하기
 *   3. 스택 자료구조에 값이 없을 때까지 반복하기
 * */
public class DFS {
    public static void main(String[] args) throws IOException {
        DFS_MyAnswer myAnswer = new DFS_MyAnswer();

        //문제 1(05-1-023) : 연결 요소의 개수 구하기
        /************************************** 개 요 *************************************
         * 방향 없는 그래프가 주어졌을 때 연결 요소(connected component)의 개수를 구하는 프로그램을 작성
         * */
        //입력 : 1번째 줄에 수의 개수 N(1 <= N <= 1,000)과 에지의 개수 M(0 <= M <= N*(N-1)/2)
        //      2번째 줄부터 M개의 줄에 에지의 양끝 점 u와 V가 주어진다(1 <= u, v <= N, u != v)
        //      같은 에지는 한 번만 주어진다.
        //출력 : 1번째 줄에 연결 요소의 개수를 출력한다
        //[예제 입력1] : 6 5 // 노드 개수, 에지 개수
        //              1 2
        //              2 5
        //              5 1
        //              3 4
        //              4 6
        //[예제 출력1] : 2
        System.out.println("문제 1(05-1-023) : 연결 요소의 개수 구하기");
        myAnswer.countConnectedComponent();

        //문제 2(05-1-024) : 신기한 소수 찾기
        /************************************** 개 요 *************************************
         * 신기한 소수는 숫자 N에 대해 어떠한 자리수로 잘라도 소수가 되는 수이다.
         * 수빈이는 N의 자리의 숫자 중 어떤 수들이 신기한 소수인지 궁금해졌다.
         * 숫자 N이 주어졌을 때 N의 자리 숫자 중 신기한 소수를 모두 찾아보자.
         * */
        //입력 : 1번째 줄에 N(1 <= N <= 8)이 주어진다.
        //출력 : N의 자리 숫자 중 신기한 소수를 오름차순 정렬해 1줄에 1개씩 출력한다.
        //[예제 입력1] : 4 (자리 수)
        //[예제 출력1] : 2333
        //              2339
        //              2393
        //              2399
        //              2939
        //              3119
        //              3137
        //              3733
        //              3739
        //              3793
        //              3797
        //              5939
        //              7193
        //              7331
        //              7333
        //              7393
        System.out.println("문제 1(05-1-023) : 연결 요소의 개수 구하기");
        myAnswer.countConnectedComponent_MyAnswer();
    }


}
