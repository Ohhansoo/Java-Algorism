package com.algorism.searching.breadthFirstSearch;

import com.algorism.searching.depthFirstSearch.DFS_MyAnswer;

import java.io.IOException;

/**
 * 너비 우선 탐색 : 그래프 완전 탐색 기법 중 하나
 *                시작 노드에서 출발해 시작 노드를 기준으로 가까운 노드를 먼저 방문하면서 탐색
 *                탐색 시작 노드와 가까운 노드를 우선 탐색하여, 목표 노드에 도착하는 경로가 여러개 일때 최단 경로 보장
 *  - 기능 : 그래프 완전 탐색
 *  - 특징 : FIFO 탐색, Queue 자료구조 이용
 *  - 시간 복잡도(노드 수 : V, 에지 수 : E) : O(V + E)
 *  - 응용 문제 : 단절점 찾기, 단절선 찾기, 사이클 찾기, 위상 정렬
 *  [과정]
 *   1. BFS를 시작할 노드를 정한 후 사용할 자료구조 초기화하기
 *   2. 큐에서 노드를 꺼낸 후 꺼낸 노드의 인접 노드를 다시 큐에 삽입하기
 *   3. 큐 자료구조에 값이 없을 때까지 반복하기
 * */
public class BFS {
    public static void main(String[] args) throws IOException {
        BFS_MyAnswer myAnswer = new BFS_MyAnswer();

        //문제 1(05-2-026) : DFS와 BFS 프로그램
        /************************************** 개 요 *************************************
         * 그래프를 DFS로 탐색한 결과와 BFS로 탐색한 결과를 출력하는 프로그램을 작성하시오.
         * 단 방문할 수 있는 노드가 여러 개일 경우에는 번호가 작은 것을 먼저 방문하고,
         * 더 이상 방문할 수 있는 노드가 없을 때 종료한다. 노드 번호는 1에서 N까지이다.
         * */
        //입력 : 1번째 줄에 수의 개수 N(1 <= N <= 1,000)과 에지의 개수 M(1 <= M <= 10,000), 탐색을 시작할 노드 번호 V
        //      2번째 줄부터 M개의 줄에 에지가 연결하는 두 노드의 번호
        //      어떤 두 노드 사이에 여러 개의 에지가 있을 수 있다.
        //      입력으로 주어지는 에지는 양방향이다.
        //출력 : 1번째 줄에 DFS를 수행한 결과, 그 다음 줄에 BFS를 수행한 결과를 출력한다.
        //      V부터 방문된 점을 순서대로 출력하면 된다.
        //[예제 입력1] : 4 5 1 // 노드 개수, 에지 개수, 시작점
        //              1 2
        //              1 3
        //              1 4
        //              2 4
        //              3 4
        //[예제 출력1] : 1 2 4 3
        //              1 2 3 4
        System.out.println("문제 1(05-2-026) : DFS와 BFS 프로그램");
        //myAnswer.DFSAndBFSProgram();

        //문제 2(05-2-027) : 미로 탐색하기
        /************************************** 개 요 *************************************
         * 4 * 6 크기의 배열로 표현되는 미로가 있다.
         * 이동할 수 있는 칸은 1, 없는 칸은 0이다.
         * 이동 시 서로 인접한 칸으로만 가능하다.
         * 이동한 칸을 셀 때는 시작 위치와 도착 위치를 포함한다.
         * N * M 크기의 미로가 주어질 때 (1, 1)에서 (N, M)의 위치로 이동하기 위해 지나야 하는 칸 수의 최솟값을 구하는 프로그램을 작성하자.
         * */
        //입력 : 1번째 줄에 두 정수 N,M(2 <= N,M <= 100), 그 다음 N개의 줄에는 미로의 내용이 M개의 정수로 주어진다.
        //      각각의 수들은 붙어서 입력된다.
        //출력 : 1번째 줄에 지나야 하는 칸 수의 최솟값을 출력한다. 항상 도착 위치로 이동할 수 있을 때만 입력으로 주어진다.
        //[예제 입력1] : 4 6 // N, M
        //              101111
        //              101010
        //              101011
        //              111011
        //[예제 출력1] : 15
        System.out.println("문제 2(05-2-027) : 미로 탐색하기");
        //myAnswer.exploreMaze();

        //문제 3(05-2-028) : 트리의 지름 구하기
        /************************************** 개 요 *************************************
         * 트리의 지름은 트리르 구성하는 노드 중 두 노드 사이의 거리가 가장 긴 것을 말한다. 트리의 지름을 구하시오.
         * */
        //입력 : 1번째 줄에서는 트리의 노드 개수 V(2 <= V <= 100,000)
        //      2번째 줄부터 V개의 줄에 걸쳐 에지의 정보가 주어진다.
        //      먼저 노드 번호가 주어지고, 그 다음으로 연결된 에지의 정보를 의미하는 정수가 2개씩 주어진다.(연결된 노드 번호, 거리)
        //      거리는 10,000 이하의 자연수다. -1은 더이상 노드가 없으므로 종료한다는 의미다.
        //출력 : 트리의 지름을 출력한다.
        //[예제 입력1] : 5 // 노드 개수
        //              1 3 2 -1
        //              2 4 4 -1
        //              3 1 2 4 3 -1
        //              4 2 4 3 3 5 6 -1
        //              5 4 6 -1
        //[예제 출력1] : 11
        System.out.println("문제 3(05-2-028) : 트리의 지름 구하기");
        myAnswer.findTreeDiameter();

    }
}
